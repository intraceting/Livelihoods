{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial{\*\falt Helvetica};}{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f34\froman\fcharset238\fprq2 Times New Roman CE;}{\f35\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f37\froman\fcharset161\fprq2 Times New Roman Greek;}{\f38\froman\fcharset162\fprq2 Times New Roman Tur;}{\f39\froman\fcharset186\fprq2 Times New Roman Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\sa240\nowidctlpar\adjustright \fs20 \snext0 Normal;}{\s1\sb240\sa60\keepn\nowidctlpar\tx432\adjustright \b\f1\fs28\kerning28 \sbasedon0 \snext0 heading 1;}{\s2\sb240\sa240\keepn\nowidctlpar\tx576\adjustright \b\i\f1 \sbasedon0 \snext0 heading 2;}{\s3\sb240\sa240\keepn\nowidctlpar\tx720\adjustright \b \sbasedon0 \snext0 heading 3;}{\s4\sb240\sa60\keepn\nowidctlpar\tx864\adjustright \b\f1 \sbasedon0 \snext0 heading 4;}{\s5\sb240\sa60\nowidctlpar\tx1008\adjustright \fs22 \sbasedon0 \snext0 heading 5;}{\s6\sb240\sa60\nowidctlpar\tx1152\adjustright \i\fs22 \sbasedon0 \snext0 heading 6;}{\s7\sb240\sa60\nowidctlpar\tx1296\adjustright \f1\fs20 \sbasedon0 \snext0 heading 7;}{\s8\sb240\sa60\nowidctlpar\tx1440\adjustright \i\f1\fs20 \sbasedon0 \snext0 heading 8;}{\s9\sl240\slmult0\nowidctlpar\tx1584\adjustright \fs2\lang0 \sbasedon0 \snext0 heading 9;}{\*\cs10 \additive Default Paragraph Font;}{\s15\li360\nowidctlpar\adjustright \f2\fs20\cf1 \sbasedon0 \snext15 Code;}{\s16\li720\sa240\nowidctlpar\adjustright \fs20 \sbasedon0 \snext16 Normal Indent;}{\s17\fi-360\li360\sa240\nowidctlpar\adjustright \fs20 \sbasedon0 \snext17 List;}{\*\cs18 \additive \ul\cf2 \sbasedon10 Hyperlink;}{\s19\sa240\nowidctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20 \sbasedon0 \snext19 header;}{\s20\qc\sb240\sa60\nowidctlpar\adjustright \b\f1\fs32\kerning28 \sbasedon0 \snext20 Title;}{\s21\sa240\nowidctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20 \sbasedon0 \snext21 footer;}{\s22\qc\sa60\nowidctlpar\adjustright \f1 \sbasedon0 \snext22 Subtitle;}}{\*\listtable{\list\listtemplateid-1\listsimple{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat0\levelspace0\levelindent0{\leveltext\'01*;}{\levelnumbers;}}{\listname ;}\listid-2}}{\*\listoverridetable{\listoverride\listid-2\listoverridecount1{\lfolevel\listoverrideformat{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent360{\leveltext\'01o;}{\levelnumbers;}\fi-360\li1080 }}\ls1}{\listoverride\listid-2\listoverridecount1{\lfolevel\listoverrideformat{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent360{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\fbias0 \fi-360\li360 }}\ls2}}{\info{\title Authentication}{\author Paul Leach}{\operator Paul Leach}{\creatim\yr1997\mo3\dy24\hr18\min28}{\revtim\yr1997\mo3\dy24\hr18\min30}{\printim\yr1997\mo3\dy21\hr19\min22}{\version3}{\edmins2}{\nofpages7}{\nofwords2746}{\nofchars15653}{\*\company Microsoft}{\nofcharsws19222}{\vern71}}\margl1008\margr864 \widowctrl\ftnbj\aendnotes\aftnstart0\hyphhotz0\aftnnar\hyphcaps0\viewkind4\viewscale100 \fet0\sectd \psz1\linex0\endnhere\titlepg\sectdefaultcl {\header \pard\plain \s19\sa240\nowidctlpar\tqc\tx4320\tqr\tx9360\adjustright \fs20 {\i Preliminary\tab }{CIFS Authentication\tab }{\i May  change without notice
\par }}{\footer \pard\plain \s21\sa240\nowidctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20 {\field{\*\fldinst { AUTHOR }}{\fldrslt {\lang1024 Paul Leach}}}{\tab Page }{\field{\*\fldinst { PAGE }}{\fldrslt {\lang1024 7}}}{\tab }{\field{\*\fldinst { DATE }}{\fldrslt {\lang1024 03/22/97}}}{
\par }}{\footerf \pard\plain \s21\sa240\nowidctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20 {\field{\*\fldinst { AUTHOR }}{\fldrslt {\lang1024 Paul Leach}}}{\tab Page }{\field{\*\fldinst { PAGE }}{\fldrslt {\lang1024 1}}}{\tab }{\field{\*\fldinst { DATE }}{\fldrslt {\lang1024 03/22/97}}}{
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s20\qc\sb240\sa60\nowidctlpar\adjustright \b\f1\fs32\kerning28 {CIFS Authentication Protocols Specification
\par }\pard\plain \s22\qc\sa60\nowidctlpar\adjustright \f1 {Paul J. Leach
\par Microsoft
\par }{\i\fs20 Preliminary Draft \endash  do not cite
\par }{\fs16 Author's draft: 4 
\par }\pard\plain \sa240\nowidctlpar\adjustright \fs20 {This is a preliminary draft of a specification of a proposed new version of the CIFS authentication protocol. It is supplied here as a standalone document for ease of review; if accepted and implemented, it may be incorporated into a future release of the CIFS specification. (This specification may change without notice, and should not be construed as a product commitment from Microsoft Corporation.)
\par There are two sections: one about the authentication protocols themselves; and one about how the protocol to use is negotiated and the protocol messages transported in CIFS requests and responses.
\par }\pard\plain \s1\sb240\sa60\keepn\nowidctlpar\tx432\outlinelevel0\adjustright \b\f1\fs28\kerning28 {1.\tab CIFS Authentication Protocols
\par }\pard\plain \sa240\nowidctlpar\adjustright \fs20 {This section defines the CIFS session and message authentication protocols. Session authentication is done via a challenge response protocol based upon the shared knowledge of the user's password. Message authentication is done by attaching a message authentication code (MAC) to each message.
\par }\pard\plain \s2\sb240\sa240\keepn\nowidctlpar\tx576\outlinelevel1\adjustright \b\i\f1 {1.1\tab Overview
\par }\pard\plain \sa240\nowidctlpar\adjustright \fs20 {There are several variations on one basic session authentication scheme: To gain authenticated access to server resources, the server sends a "challenge" to the client, which the client responds to in a way that proves it knows the client's password: a "response" is created from  the challenge by  encrypting it (and possibly a nonce of the client's choice) with a 168 bit "session key" computed from the user's password. The response, or a subset of it, and client nonce are then returned to the server, which can validate the response by performing the same computation. The client and server negotiate which variation to use by a mechanism described in the next section (being careful to not permit a downgrade attack).
\par We describe the session authentication protocol as if the CIFS server keeps a client\rquote s password, but an implementation might actually store the passwords on a key distribution server (KDS) and have servers use a protocol outside the scope of this specification  to enable them to perform the steps required by this protocol.
\par Once the session is authenticated, subsequent messages may be authenticated by computing a MAC for each message and attaching it to the message. The MAC used is a keyed MD5 construction similar to that used in IPSec [RFC 1828], using a "MAC key" computed from the session key, and the response to the server's challenge. The MAC is over both the message text and an implicit sequence number, to prevent replay.
\par }\pard\plain \s2\sb240\sa240\keepn\nowidctlpar\tx576\outlinelevel1\adjustright \b\i\f1 {1.2\tab Definitions
\par }\pard\plain \sa240\nowidctlpar\adjustright \fs20 {Let
\par }\pard\plain \s17\fi-360\li360\sa240\nowidctlpar\adjustright \fs20 {\f2 E(K, D)}{\line denote the DES block mode encryption function [FIPS 81] , which accepts a seven byte key (K) and an eight byte data block (D) and produces an eight byte encrypted data block as its value.
\par }{\f2 Ex(K,D)\line }{denote the extension of DES to longer keys and data blocks. If the data to be encrypted is longer than eight bytes, the encryption function is applied to each block of eight bytes in sequence and the results are concatenated together.  If the key is longer than seven bytes, each 8 byte block of data is first completely encrypted using the first seven bytes of the key, then the second seven bytes, etc., appending the results each time.  For example, to encrypt the 16 byte quantity D0D1 with the 14 byte key K0K1, 
\par }\pard\plain \s15\li360\nowidctlpar\adjustright \f2\fs20\cf1 {\tab Ex(K0K1,D0D1) = concat(E(K0,D0),E(K0,D1),E(K1,D0),E(K1,D1))
\par 
\par }\pard\plain \s17\fi-360\li360\sa240\nowidctlpar\adjustright \fs20 {\f2 concat(A, B, …, Z)\line is the result of concatenating the byte strings A, B, … Z
\par head(S, N)}{\line denote the first N bytes of the byte string S.
\par }{\f2 swab(S)}{\line denote the byte string obtained by reversing the order of the bits in each byte of S, i.e., if S is byte string of length one, with the value 0x37 then swab(S) is 0xEC.
\par }{\f2 zeros(N)\line }{denote a  byte string of length N whose bytes all have value 0 (zero).
\par }{\f2 ones(N)\line }{denote a  byte string of length N whose bytes all have value 255.
\par }{\f2 xor(A, B)}{\line denote a byte string formed by the bytewise logical "xor" of each of the bytes in A and B.
\par }{\f2 and(A, B)}{\line denote a byte string formed by the bytewise logical "and" of each of the bytes in A and B.
\par }{\f2 substr(S, A, B)}{\line denote a byte string of length N obtained by taking N bytes of S starting at byte A. The first byte is numbered zero. I.e., if S is the string "NONCE" then substr(S, 0, 2) is "NO".
\par }\pard\plain \s2\sb240\sa240\keepn\nowidctlpar\tx576\outlinelevel1\adjustright \b\i\f1 {1.3\tab Session Keys
\par }\pard\plain \sa240\nowidctlpar\adjustright \fs20 {The session authentication protocol is the same for all dialects, but the computation of the session keys is different depending on the dialect and the authentication negotiation described below.
\par }\pard\plain \s3\sb240\sa240\keepn\nowidctlpar\tx720\outlinelevel2\adjustright \b {{\*\bkmkstart _Toc365655276}1.3.1\tab NT Session Key
\par }\pard\plain \sa240\nowidctlpar\adjustright \fs20 {The session key  S21 and partial MAC key S16 are computed as
\par }\pard\plain \s15\li360\nowidctlpar\adjustright \f2\fs20\cf1 {S16 = MD4(U(PN))
\par S21 = concat(S16, zeros(5))
\par 
\par }\pard\plain \sa240\nowidctlpar\adjustright \fs20 {where
\par {\pntext\pard\plain\fs20 \hich\af0\dbch\af0\loch\f0 o\tab}}\pard \fi-360\li1080\sa240\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnstart1\pnindent360\pnhang{\pntxtb o}}\ls1\adjustright {PN is a string containing the user\rquote s password in clear text, case sensitive, no maximum length
\par {\pntext\pard\plain\fs20 \hich\af0\dbch\af0\loch\f0 o\tab}}\pard \fi-360\li1080\sa240\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnstart1\pnindent360\pnhang{\pntxtb o}}\ls1\adjustright {U(x) of an ASCII string "x" is that string converted to Unicode
\par {\pntext\pard\plain\fs20 \hich\af0\dbch\af0\loch\f0 o\tab}}\pard \fi-360\li1080\sa240\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnstart1\pnindent360\pnhang{\pntxtb o}}\ls1\adjustright {MD4(x) of an byte string "x" is the 16 byte MD4 message digest [RFC 1320] of that string
\par }\pard\plain \s3\sb240\sa240\keepn\nowidctlpar\tx720{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\outlinelevel2\adjustright \b {{\*\bkmkend _Toc365655276}1.3.2\tab LM Session Key
\par }\pard\plain \sa240\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright \fs20 {The session key  S21 and partial MAC key S16 are computed as
\par }\pard\plain \s15\li360\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright \f2\fs20\cf1 {S16X = Ex(swab(P14),N8)
\par }\pard \s15\li360\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright {S21 = concat(S16X, zeros(5))
\par }\pard \s15\li360\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright {S16 = concat(head(S16X, 8), zeros(8))
\par }\pard \s15\li360\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright {
\par }\pard\plain \sa240\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright \fs20 {where 
\par {\pntext\pard\plain\fs20 \hich\af0\dbch\af0\loch\f0 o\tab}}\pard \fi-360\li1080\sa240\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnstart1\pnindent360\pnhang{\pntxtb o}}\ls1\adjustright {P14 is a 14 byte string containing the user\rquote s password in clear text, upper cased, padded with spaces
\par {\pntext\pard\plain\fs20 \hich\af0\dbch\af0\loch\f0 o\tab}}\pard \fi-360\li1080\sa240\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnstart1\pnindent360\pnhang{\pntxtb o}}\ls1\adjustright {N8 is an 8 byte string whose value is available from Microsoft upon request.
\par }\pard\plain \s2\sb240\sa240\keepn\nowidctlpar\tx576{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\outlinelevel1\adjustright \b\i\f1 {1.4\tab Session Authentication Protocol
\par }\pard\plain \sa240\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright \fs20 {The session authentication protocol has the following steps:
\par {\pntext\pard\plain\fs20 \hich\af0\dbch\af0\loch\f0 o\tab}}\pard \fi-360\li360\sa240\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnstart1\pnindent360\pnhang{\pntxtb o}}\ls1\adjustright {The server chooses a unique 8 byte challenge C8 (a "nonce" that has never been used before and will not be reused) and sends it to the client
\par {\pntext\pard\plain\fs20 \hich\af0\dbch\af0\loch\f0 o\tab}}\pard \fi-360\li360\sa240\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnstart1\pnindent360\pnhang{\pntxtb o}}\ls1\adjustright {The client computes
\par }\pard\plain \s15\li360\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright \f2\fs20\cf1 {RN = Ex(S21,C8)
\par }\pard \s15\li360\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright {
\par {\pntext\pard\plain\fs20 \hich\af0\dbch\af0\loch\f0 o\tab}}\pard\plain \fi-360\li360\sa240\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnstart1\pnindent360\pnhang{\pntxtb o}}\ls1\adjustright \fs20 {The client sends the 24 byte response RN to the server
\par {\pntext\pard\plain\fs20 \hich\af0\dbch\af0\loch\f0 o\tab}}\pard \fi-360\li360\sa240\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnstart1\pnindent360\pnhang{\pntxtb o}}\ls1\adjustright {The server computes RN as above and compares the received response with its computed value for RN; if equal, the client has authenticated.
\par }\pard\plain \s2\sb240\sa240\keepn\nowidctlpar\tx576{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\outlinelevel1\adjustright \b\i\f1 {1.6\tab Message authentication code
\par }\pard\plain \sa240\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright \fs20 {The MAC is the keyed MD5 construction:
\par }\pard\plain \s15\li360\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright \f2\fs20\cf1 {MAC(K, text) = head(MD5(concat(K, text)), 8)
\par }\pard \s15\li360\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright {
\par }\pard\plain \sa240\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright \fs20 {Where:
\par }\pard\plain \s17\fi-360\li360\sa240\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright \fs20 {\f2 MD5\line }{is the MD5 hash function; see RFC 1321
\par }\pard \s17\fi-360\li360\sa240\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright {\f2 K\line }{is the key
\par }\pard \s17\fi-360\li360\sa240\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright {\f2 text\line }{is the message whose MAC is being computed
\par }\pard\plain \sa240\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright \fs20 {See RFC 1828 for an example of Keyed-MD5 applied to IP security. If not used properly, keyed MD5 may have weaknesses as a MAC. Iterative hashes such as MD5 may be subject to message extension attacks and to cryptanalysis [Kal 95]. This construction is not subject to the problems identified there, because the text contains an explicit length, which prevents message extension attacks; and because there are always two iterations of the compression function, and only 64 bits of the hash are output, which prevents known cryptanalysis techniques.
\par }\pard\plain \s2\sb240\sa240\keepn\nowidctlpar\tx576{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\outlinelevel1\adjustright \b\i\f1 {1.7\tab MAC key
\par }\pard\plain \sa240\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright \fs20 {The MAC key is computed as follows:
\par }\pard\plain \s15\li360\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright \f2\fs20\cf1 {K = concat(S16, RN)
\par }\pard \s15\li360\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright {
\par }\pard\plain \sa240\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright \fs20 {Where S16 and RN are as above. K is either 40 or 44 bytes long, depending on the length of RN.
\par }\pard\plain \s2\sb240\sa240\keepn\nowidctlpar\tx576{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\outlinelevel1\adjustright \b\i\f1 {1.8\tab Message Authentication Protocol
\par }\pard\plain \sa240\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright \fs20 {Once the session has been authenticated, each message can be authenticated as well. This will prevent MITM attacks, replay attacks, and active message modification attacks. (See Security Considerations, below.)
\par }\pard \sa240\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright {Let
\par }\pard\plain \s17\fi-360\li360\sa240\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright \fs20 {SN\line be a request sequence number, initially set to 0. Both client and server have one SN for each connection between them. 
\par }\pard \s17\fi-360\li360\sa240\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright {RSN\line is the sequence number expected on the response to a request.
\par }\pard \s17\fi-360\li360\sa240\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright {req_msg\line be a request message
\par }\pard \s17\fi-360\li360\sa240\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright {rsp_msg\line be a response message
\par }\pard\plain \sa240\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright \fs20 {The SN is logically contained in each message, as defined below in the section on authenticated message transport, and participates in the computation of the MAC, as defined in that section.
\par }\pard \sa240\nowidctlpar{\*\pn \pnlvlcont\ilvl12\ls0\pnrnot0\pndec }\ilvl12\adjustright {Then for or each message sent in the session the following procedure is followed:
\par {\pntext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \fi-360\li360\sa240\nowidctlpar\tx360{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls2\adjustright {Client computes MAC(req_msg) using SN, and sends it to the server in the request message. If there are multiple messages in the request, each uses the same SN. If there are multiple requests in the message (using the "AndX" facility) , then the MAC is calculated as if it were a single large request.
\par {\pntext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}Client increments its SN and saves it as RSN
\par {\pntext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}Client increments its SN \endash  this is the SN it will use in its next request
\par {\pntext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}Server receives each req_msg, validates MAC(req_msg) using SN, and responds ACCESS_DENIED if invalid
\par {\pntext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}Server increments its SN and saves it as RSN
\par {\pntext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}Server increments its SN \endash  this is the SN it will expect in the next request
\par {\pntext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}For each response message for this request, computes MAC(rsp_msg) using RSN, and sends it  to client in the response message. If there are multiple responses in the message (using the "AndX" facility) , then the MAC is calculated as if it were a single large response.
\par {\pntext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}Client receives each rsp_msg, validates MAC(rsp_msg) using RSN, and discards the response message if invalid
\par }\pard\plain \s1\sb240\sa60\keepn\nowidctlpar\tx432\outlinelevel0\adjustright \b\f1\fs28\kerning28 {2.\tab Security Level and Authentication Protocol Negotiation
\par }\pard\plain \sa240\nowidctlpar\adjustright \fs20 {The }{\f2\fs18 SMB_COM_NEGPROT}{ response from a server has the following bits in its }{\i SecurityMode}{ field:
\par }\pard\plain \s15\li360\nowidctlpar\adjustright \f2\fs20\cf1 {#define NEGOTIATE_SECURITY_USER_LEVEL               0x01
\par #define NEGOTIATE_SECURITY_CHALLENGE_RESPONSE       0x02
\par #define NEGOTIATE_SECURITY_SIGNATURES_ENABLED       0x04
\par #define NEGOTIATE_SECURITY_SIGNATURES_REQUIRED      0x08
\par 
\par }\pard\plain \sa240\nowidctlpar\adjustright \fs20 {If NEGOTIATE_SECURITY_USER_LEVEL is set, then "user level" security is in effect for all the shares on the server. This means that the client MUST establish a session (with SMB_COM_SESSION_SETUP_ANX) to authenticate the user before connecting to a share, and the password to use in the authentication protocol described above is the user's password. If NEGOTIATE_SECURITY_USER_LEVEL is clear, then "share level" security is in effect for all the shares in the server. This means that a session need not be established, and the password to use in the authentication protocol is a password for the share.
\par If NEGOTIATE_SECURITY_CHALLENGE_RESPONSE is clear, then the server is requesting plaintext passwords. Clients MUST be able to be configured to refuse requests for plaintext passwords (in order to prevent downgrade attacks by rogue or spoofing servers); this SHOULD be the default. Servers MUST be able to be configured to refuse plaintext passwords (in order to make password guessing attacks harder).
\par If NEGOTIATE_SECURITY_CHALLENGE_RESPONSE is set, then the server supports the challenge/response session authentication protocol described above, and clients SHOULD use it. Servers MAY refuse connections that do not use it, and MUST be able to be configured to do so. 
\par If the dialect is earlier than "NTLM 0.12" then the client computes the response using the "LM session key". If the dialect is "NTLM 0.12" then the client MAY compute the response either using the "LM session key", or the "NT session key", or both. The server MAY choose to refuse responses computed using the "LM session key", and MUST be able to be configured to do so (in order to protect against downgrade attacks).
\par If NEGOTIATE_SECURITY_SIGNATURES_ENABLED is set, then the server supports the message authentication protocol described above, and the client MAY use it. This bit may only be set if NEGOTIATE_SECURITY_CHALLENGE_RESPONSE is set. Clients that support security signatures MUST be configurable to refuse to connect to servers that do not have NEGOTIATE_SECURITY_SIGNATURES_ENABLED set. Clients that are so configured MUST refuse to connect to servers that have NEGOTIATE_SECURITY_CHALLENGE_RESPONSE  set and do not have NEGOTIATE_SECURITY_USER_LEVEL set (i.e., they must not use challenge/response authentication to a server using "share-level" security).
\par If NEGOTIATE_SECURITY_SIGNATURES_REQUIRED is set, then the server requires the use of the message authentication protocol described above, and the client MUST use it. This bit may only be set if NEGOTIATE_SECURITY_SIGNATURES_ENABLED is set. This bit MUST NOT be set. if NEGOTIATE_SECURITY_USER_LEVEL is clear (i.e., for servers using "share level" security).
\par The SMB_COM_SESSION_SETUP_ANDX request has the following bit in the }{\i Flags2}{ field:
\par }\pard\plain \s15\nowidctlpar\adjustright \f2\fs20\cf1 {#define SMB_FLAGS2_SMB_SECURITY_SIGNATURE 0x0004
\par }\pard \s15\li360\nowidctlpar\adjustright {\f1\cf2 
\par }\pard\plain \sa240\nowidctlpar\adjustright \fs20 {To use  message authentication, the client sets }{\f2 SMB_FLAGS2_SMB_SECURITY_SIGNATURE }{in a SMB_COM_SESSION_SETUP_ANDX request to the server, and includes a MAC calculated as described above.  If the  resulting session is non-null and non-guest, then the SMB_COM_SESSION_SETUP_ANDX response and all subsequent SMB requests and responses MUST include a MAC calculated as described above. The first non-null, non-guest session determines the key to be used for the MAC for all subsequent sessions.
\par Message authentication may only be requested when the "NTML 0.12" dialect has been negotiated. If message authentication is used, raw mode MUST not be used (because some raw mode messages have no headers in which to carry the MAC).
\par No matter which authentication protocol is negotiated, servers MUST be able to be configured to "lock out" accounts that make too many failed authentication attempts, in order to foil brute force attacks on the protocol.
\par }\pard\plain \s2\sb240\sa240\keepn\nowidctlpar\tx576\outlinelevel1\adjustright \b\i\f1 {2.1\tab Plaintext password transport
\par }\pard\plain \sa240\nowidctlpar\adjustright \fs20 {If plaintext password authentication was negotiated, clients send the plaintext password in the first }{\f2\fs18 SMB_COM_TREE_CONNECT}{, }{\f2\fs18 SMB_COM_TREE_CONNECT_ANDX}{, and/or }{\f2\fs18 SMB_COM_SESSION_SETUP_ANDX}{ request which follows the }{\f2\fs18 SMB_COM_NEGPROT}{ message exchange.  The SMB field used to contain the response depends upon the request:
\par {\pntext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \fi-360\li720\sa240\nowidctlpar\tx720{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls2\adjustright {\i Password}{ in }{\f2\fs18 SMB_COM_TREE_CONNECT}{
\par {\pntext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}{\i Password}{ in }{\f2\fs18 SMB_COM_TREE_CONNECT_ANDX
\par {\pntext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}{\i AccountPassword}{ }{\f2\fs18 in SMB_COM_SESSION_SETUP_ANDX}{ in dialects prior to "NTLM 0.12"
\par {\pntext\pard\plain\f3\fs18 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}{\i\fs18 CaseInsensitivePassword}{\fs18  in }{\f2\fs18 SMB_COM_SESSION_SETUP_ANDX}{\fs18  }{in the "NTLM 0.12" dialect
\par {\pntext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}{\i CaseSensitivePassword}{ in }{\f2\fs18 SMB_COM_SESSION_SETUP_ANDX}{  in the "NTLM 0.12" dialect
\par }\pard\plain \s2\sb240\sa240\keepn\nowidctlpar\tx576\outlinelevel1\adjustright \b\i\f1 {2.2\tab Challenge/response transport
\par }\pard\plain \sa240\nowidctlpar\adjustright \fs20 {The challenge C8 from the server to the client is contained in the }{\i EncryptionKey}{ field in the }{\f2\fs18 SMB_COM_NEGPROT}{ response.  (Note: the name "}{\i EncryptionKey}{" is historical -- it doesn't actually hold an encryption key.)
\par Clients send the cleartext password, or the response to the challenge, in the first }{\f2\fs18 SMB_COM_TREE_CONNECT}{, }{\f2\fs18 SMB_COM_TREE_CONNECT_ANDX}{, and/or }{\f2\fs18 SMB_COM_SESSION_SETUP_ANDX}{ request which follows the }{\f2\fs18 SMB_COM_NEGPROT}{ message exchange.  The SMB field used to contain the response depends upon the request:
\par {\pntext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \fi-360\li720\sa240\nowidctlpar\tx720{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls2\adjustright {\i Password}{ in }{\f2\fs18 SMB_COM_TREE_CONNECT}{
\par {\pntext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}{\i Password}{ in }{\f2\fs18 SMB_COM_TREE_CONNECT_ANDX
\par {\pntext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}{\i AccountPassword}{ }{\f2\fs18 in SMB_COM_SESSION_SETUP_ANDX}{ in dialects prior to "NTLM 0.12"
\par {\pntext\pard\plain\f3\fs18 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}{\i\fs18 CaseInsensitivePassword}{\fs18  in }{\f2\fs18 SMB_COM_SESSION_SETUP_ANDX}{\fs18  for a response computed using the "LM session key" }{in the "NTLM 0.12" dialect
\par {\pntext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}{\i CaseSensitivePassword}{ in }{\f2\fs18 SMB_COM_SESSION_SETUP_ANDX}{ for a response computed using the "NT session key" in the "NTLM 0.12" dialect
\par }\pard \sa240\nowidctlpar\adjustright { (Note: again, the names are historical, and do not reflect this usage.)
\par }\pard\plain \s2\sb240\sa240\keepn\nowidctlpar\tx576\outlinelevel1\adjustright \b\i\f1 {2.3\tab MAC transport
\par }\pard\plain \sa240\nowidctlpar\adjustright \fs20 {In each message that contains a MAC, the following bit is set in the flags2 field:
\par }\pard\plain \s15\nowidctlpar\adjustright \f2\fs20\cf1 {#define SMB_FLAGS2_SMB_SECURITY_SIGNATURES 0x0004
\par }\pard \s15\li360\nowidctlpar\adjustright {\f1\cf2 
\par }\pard\plain \sa240\nowidctlpar\adjustright \fs20 {The SMB header has been modified to include a place for the MAC:
\par }\pard\plain \s15\nowidctlpar\adjustright \f2\fs20\cf1 {typedef struct _SMB_HEADER \{
\par     UCHAR Protocol[4];              // Contains 0xFF,'SMB'
\par     UCHAR Command;                 \tab // Command code
\par     UCHAR ErrorClass;               // Error class
\par     UCHAR Reserved;                 // Reserved for future use
\par     USHORT Error ;                  // Error code
\par     UCHAR Flags;                    // Flags
\par     USHORT Flags2 ;                 // More flags
\par     union \{
\par         USHORT Reserved2[6];        // Reserved for future use
\par         struct \{
\par             USHORT PidHigh;   \tab // High part of PID
\par                \tab // Client must send the correct Signature
\par }\pard \s15\fi720\li1440\nowidctlpar\adjustright {// for this SMB to be accepted.
\par }\pard \s15\nowidctlpar\adjustright {            UCHAR SecuritySignature[8];
\par         \};
\par     \};
\par    ....
\par \} SMB_HEADER;
\par 
\par }\pard\plain \sa240\nowidctlpar\adjustright \fs20 {The sender of a message inserts the sequence number SSN into the message by putting it into the first 4 bytes of the SecuritySignature field and zeroing the last 4 bytes, computes the MAC over the entire message, then puts the MAC in the field. The receiver of a message validates the MAC by extracting the value of the SecuritySignature field, putting its ESN into the first 4 bytes of the SecuritySignature field and zeroing the last 4 bytes, computing the MAC, and comparing it to the extracted value.
\par Oplock break messages from the server to the client may not use message authentication, even if it has been negotiated.
\par }\pard\plain \s1\sb240\sa60\keepn\nowidctlpar\tx432\outlinelevel0\adjustright \b\f1\fs28\kerning28 {3.\tab Security considerations
\par }\pard\plain \sa240\nowidctlpar\adjustright \fs20 {(These are already in the main CIFS spec, of which this will eventually become a part.) Relevant additions:
\par Clients  that require the use of message authentication will be protected against man-in-the-middle attacks and downgrade attacks by rogue or counterfeit servers. Servers that require the use of message authentication will be protected against man-in-the-middle attacks and downgrade attacks by rogue clients.
\par }\pard\plain \s1\sb240\sa60\keepn\nowidctlpar\tx432\outlinelevel0\adjustright \b\f1\fs28\kerning28 {4.\tab References
\par }\pard\plain \sa240\nowidctlpar\adjustright \fs20 {[FIPS 81] DES, FIPS PUB xxx
\par [RFC 1320] RFC 1320, R. Rivest, The MD4 Message-Digest Algorithm
\par [RFC 1321] RFC 1321, R. Rivest, The MD5 Message-Digest Algorithm
\par [RFC 1828] RFC 1828, P. Metzger, W. Simpson, "IP Authentication using Keyed MD5", August 1995
\par \{Kal 95] B. Kaliski, M.Robshaw,  "Message Authentication with MD5",  CryptoBytes, Sping 1995, RSA Inc, (http://www.rsa.com/rsalabs/pubs/cryptobytes/spring95/md5.htm)
\par }}